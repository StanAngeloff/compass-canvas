<!doctype html>
<html>
<head>
  <title>compass-canvas</title>
  <link rel=stylesheet href=assets/default.css>
</head>
<body>

<a href="https://github.com/StanAngeloff/compass-canvas/"><img style="position: absolute; top: 0; right: 0; border: 0;" src="https://a248.e.akamai.net/assets.github.com/img/7afbc8b248c68eb468279e8c17986ad46549fb71/687474703a2f2f73332e616d617a6f6e6177732e636f6d2f6769746875622f726962626f6e732f666f726b6d655f72696768745f6461726b626c75655f3132313632312e706e67" alt="Fork me on GitHub"></a>

<article id=main>
<h1>compass-canvas</h1>

<h3>Canvas drawing support for Compass with Cairo backend(s)</h3>

<h2>Description</h2>

<p>Canvas is a Compass plugin that provides a drawing surface similar to the <code>&lt;canvas&gt;</code> element in JavaScript and <a href="http://en.wikipedia.org/wiki/Turtle_graphics">Turtle graphics</a> in other programming languages.
It uses <a href="http://en.wikipedia.org/wiki/Cairo_(graphics)">Cairo</a> as a back-end to perform all graphics operations.
Canvas supports anti-aliasing, vector graphics, gradients, masks, clipping, complex operations like drop shadow and many more.</p>

<h2>Installation</h2>

<p>Installation is done through <a href="http://rubygems.org/">RubyGems</a>:</p>

<pre><code>gem install compass-canvas
</code></pre>

<h3>Dependencies</h3>

<p>The <code>compass-canvas</code> gem depends on the <code>cairo</code> gem. In order to install both gems, you must have Cairo's development files present on your system.
You can usually install these using your OS package manager.</p>

<h4>Ubuntu</h4>

<pre><code>sudo apt-get install libcairo2-dev
</code></pre>

<h2>Example</h2>

<div class="example">


<pre><code>@import 'canvas';

$shape: triangle(10, 10, 310, 10, 160, 190);

html {
  background: canvas(320, 200,
    $shape
    brush(10, 10, 160, 100, rgba(red, 0.5) 50%, rgba(red, 0.75))
    fill
    reset
    save
      translate(40, 20)
      scale(0.75, 0.75)
      $shape
      brush(black)
      stroke
      brush(10, 10, 160, 100, rgba(blue, 0.75) 50%, rgba(blue, 0.5))
      fill
    restore
  ) no-repeat 50% 50%;
}
</code></pre>

<p><img src="assets/images/example-1.png" alt="Example 1" /></p>

</div>


<h2>License</h2>

<p>Canvas is licensed under the MIT License.</p>

<h1>Documentation</h1>

<h2>Usage</h2>

<p>To start a new Compass project with Canvas included:</p>

<pre><code>compass create -r canvas ...
</code></pre>

<p>To use Canvas within your existing project, require the plugin from your Compass configuration (<code>config.rb</code>):</p>

<pre><code>require 'canvas';
</code></pre>

<h2>Concepts</h2>

<p>Every drawing operation is done on a surface. A surface is an area defined by (0, 0) x (width, height).
Initialising a new canvas creates an empty surface (if you were to save it to disk, it would be completely transparent).</p>

<div class="example">


<pre><code>@import 'canvas';

html {
  background: canvas(320, 200);
}
</code></pre>

<p><img src="assets/images/example-2.png" alt="Example 2" /></p>

</div>


<h3>Paths</h3>

<p>Before you can put any colours on your canvas, you need to define where and how you want to draw.
This is done by creating paths. Paths are a series of motions describing a shape.
Imagine a rectangle. If you were to take a piece of paper and sketch it, you would draw four lines.
The easiest and fastest approach is to pick an edge, put the pen down, move it across to draw one of the lines, then move it in a different direction to draw a second line and so forth until the shape is complete.</p>

<p>Creating paths in Canvas is similar - you pick a starting point, define the shape through a series of motions and close the path. Here is how you would define a rectangle:</p>

<div class="example">


<pre><code>@import 'canvas';

html {
  background: canvas(320, 200,
    move-to(10, 10)   // start at top-left
    line-to(310, 10)  // line to top-right (red)
    line-to(310, 190) // line to bottom-right (green)
    line-to(10, 190)  // line to bottom-left (blue)
    close             // close the rectangle, i.e., line to top-left (hot pink)
  );
}
</code></pre>

<p><img src="assets/images/example-3.png" alt="Example 3" /></p>

</div>


<p>There is only one path primitive in Canvas - a line. While this may seem strange, lines can be curved as well allowing you to build more complex objects.
There are five basic functions for describing a path:</p>

<ul>
<li><a href="#move-to"><code>move-to</code></a> - starts a new path at coordinates <code>X</code> and <code>Y</code> on the surface</li>
<li><a href="#line-to"><code>line-to</code></a> - creates a straight line between the current point and <code>X</code> and <code>Y</code>, moves the current point to <code>X</code> and <code>Y</code></li>
<li><a href="#curve-to"><code>curve-to</code></a> - same as above, but the line is curved</li>
<li><a href="#arc"><code>arc</code></a> and <a href="#arc-reverse"><code>arc-reverse</code></a> - same as above, but defined of many curved lines to form an arc</li>
</ul>


<p>Combining these functions allows you to build complex objects like circles, stars, polygons and many more:</p>

<div class="example">


<pre><code>@import 'canvas';

html {
  background: canvas(320, 200,
    move-to(10, 100)                  // hat, start at bottom-left
    line-to(100, 100)                 // hat, line bottom-left (red)
    arc-reverse(160, 100, 60, 180, 0) // face (green)
    line-to(310, 100)                 // hat, line bottom-right (blue)
    line-to(160, 10)                  // hat, line top-right (hot pink)
    close                             // hat, line top-left (cyan)

    move-to(120, 110)                 // left eye (brown)
    line-to(140, 110)
    arc-reverse(130, 110, 10, 180, 0)

    move-to(180, 110)                 // right eye (orange)
    line-to(200, 110)
    arc-reverse(190, 110, 10, 180, 0)
  );
}
</code></pre>

<p><img src="assets/images/example-4.png" alt="Example 4" /></p>

</div>


<h3>Brushes</h3>

<p>Once you have your basic shapes defined, your next step is to draw them.
Brushes define how a shape will be drawn on the surface.
Canvas supports the most common ones - solid colour, linear gradient and radial gradient.
The only relevant function is <a href="#brush"><code>brush</code></a> which defines and sets the brush for the next drawing operation:</p>

<div class="example">


<pre><code>@import 'canvas';

html {
  background: canvas(320, 20,
    brush(red)
  );
}
</code></pre>

<p><img src="assets/images/example-5.png" alt="Example 5" /></p>

</div>


<h3>Drawing</h3>

<p>If you have tried any of the examples so far, you would notice they don't put anything on the canvas surface, i.e., it remains transparent.
The reason for this is that paths and brushes are just instructions. Paths are transparent and brushes configure what colour or pattern the next drawing operating will be using.</p>

<p>There are two functions that combine paths and brushes to draw the shape on the canvas surface:</p>

<ul>
<li><a href="#stroke"><code>stroke</code></a> - outlines the current path with the configured brush</li>
<li><a href="#fill"><code>fill</code></a> - fills the region defined by the current path with the configured brush</li>
</ul>


<p>There is one additional action <a href="#paint"><code>paint</code></a> which applies the configured brush to the entire surface. This is useful if you would like to start with a canvas that is not transparent.
Note <code>paint</code> is not a function, i.e., you don't use parentheses <code>()</code> after it.</p>

<p>Let's draw the rectangle from earlier:</p>

<div class="example">


<pre><code>@import 'canvas';

html {
  background: canvas(320, 200,
    brush(#ccc)
    paint
    move-to(10, 10)
    line-to(310, 10)
    line-to(310, 190)
    line-to(10, 190)
    close
    brush(yellow)
    fill
    brush(black)
    stroke
  );
}
</code></pre>

<p><img src="assets/images/example-6.png" alt="Example 6" /></p>

</div>


<h3>Saving to Disk</h3>

<p>The <code>canvas</code> function has several overloads. In its default form, it takes <code>width</code> and <code>height</code>.
The final canvas is serialized as Base64 encoded Data URI.</p>

<p>Most modern browsers will be happy with this. However, if you have to support Internet Explorer 7 or if you are planning on using <a href="http://compass-style.org/reference/compass/utilities/sprites/">sprites</a>, you would want the data saved on disk.
Simply pass a filename as the first argument to the <code>canvas</code> function and the image will be saved in your configured <a href="http://compass-style.org/help/tutorials/configuration-reference/">images directory</a>.</p>

<p>Wrap the code in <a href="http://compass-style.org/reference/compass/helpers/urls/#image-url"><code>image-url</code></a> to have the correct relative path and cache buster applied.</p>

<pre><code>@import 'canvas';

html {
  background: image-url(canvas('file.png', 320, 200,
    brush(#ccc)
    paint
  ));
}
</code></pre>

<h3>Paths revised</h3>

<p>Now that you know how to define and draw a single shape, let's talk more about paths.</p>

<p>Canvas ships with several useful functions for drawing common shapes:</p>

<ul>
<li><a href="#triangle"><code>triangle</code></a></li>
<li><a href="#rectangle"><code>rectangle</code></a></li>
<li><a href="#rounded-rectangle"><code>rounded-rectangle</code></a></li>
<li><a href="#circle"><code>circle</code></a></li>
</ul>


<p>You can define your own as <a href="http://sass-lang.com/docs/yardoc/file.SASS_REFERENCE.html#functions">Sass functions</a>.
The return result of the function must be a <a href="http://sass-lang.com/docs/yardoc/file.SASS_REFERENCE.html#lists">list</a> of Canvas operations.</p>

<div class="example">


<pre><code>@import 'canvas';

@function my-shape($x, $y) {
  @return (
    move-to($x - 50, $y - 50)
    line-to($x + 50, $y - 50)
    line-to($x + 50, $y + 50)
    close
  );
}

html {
  background: canvas(320, 200,
    my-shape(150, 90)
    brush(black)
    stroke
  );
}
</code></pre>

<p><img src="assets/images/example-7.png" alt="Example 7" /></p>

</div>


<p>Initialising a new canvas instance creates a new, empty path. Every Canvas operation (<code>move-to</code>, <code>line-to</code>, etc.) is applied to this default path.
The following may have a surprising result:</p>

<div class="example">


<pre><code>@import 'canvas';

html {
  background: canvas(320, 100,
    rectangle(10, 10, 100, 30)
    brush(red)
    fill
    rectangle(40, 50, 130, 70)
    brush(blue)
    fill
  );
}
</code></pre>

<p><img src="assets/images/example-8.png" alt="Example 8" /></p>

</div>


<p>In the example above, both rectangles are considered to be part of the same path. The first call to <code>fill</code> therefore draws the first rectangle in red and the second call to <code>fill</code> draws both rectangles in blue.
To split paths in separate shapes, use the <a href="#reset"><code>reset</code></a> action to start a new path.</p>

<div class="example">


<pre><code>@import 'canvas';

html {
  background: canvas(320, 100,
    rectangle(10, 10, 100, 30)
    brush(red)
    fill
    reset                       // start a new path
    rectangle(40, 50, 130, 70)
    brush(blue)
    fill
  );
}
</code></pre>

<p><img src="assets/images/example-9.png" alt="Example 9" /></p>

</div>


<h4>Single-pixel-wide Paths</h4>

<p>In many of the examples above, the default line width of 1px is used, however lines may look slightly thicker:</p>

<div class="example">


<pre><code>@import 'canvas';

html {
  background: canvas(320, 100,
    rectangle(10, 10, 310, 90)
    stroke
  );
}
</code></pre>

<p><img src="assets/images/example-10.png" alt="Example 10" /></p>

</div>


<blockquote><p>The reason this happens is easy to explain to someone who believes pixels are little squares. By default, integer coordinates map to the intersections of the pixel squares. So a width-1 horizontal/vertical line is centered on the boundary between pixel rows and extends half way into the pixels on either side.</p>

<p>When some people hear pixels described as little squares it sets their teeth on edge. For them we have this alternate explanation. By default, integer coordinates map to points half way between sample point locations. So a width-1 horizontal/vertical will be centered between two rows of pixel sample points and will contribute equally to the pixels on either side, (assuming a symmetric filter which is always the case when synthesizing images in cairo).</p>

<p>[..] If you [..] want to light up a single row of pixels at full intensity, you can do that by adjusting the endpoints by 0.5 in the appropriate direction.</p>

<p><a href="http://cairographics.org/FAQ/#sharp_lines">The Cairo FAQ</a></p></blockquote>

<div class="example">


<pre><code>@import 'canvas';

html {
  background: canvas(320, 100,
    rectangle(10.5, 10.5, 310.5, 90.5)  // adjusted by .5
    stroke
  );
}
</code></pre>

<p><img src="assets/images/example-11.png" alt="Example 11" /></p>

</div>


<h3>Brushes revised</h3>

<h4>Linear Gradients</h4>

<p>Linear gradients are constructed from two points which determine the direction of the pattern.
For example, a vertical gradient would be defined by two points (0, 0), (0, 100), i.e., <code>x</code> remains unchanged (in both points it's zero).
A horizontal gradient therefore can be defined by (0, 0), (100, 0), i.e., <code>y</code> remains unchanged.
A diagonal gradient is defined by two points where <code>x1</code> &lt;> <code>x2</code> and <code>y1</code> &lt;> <code>y2</code>.</p>

<p>Linear gradient are constructed with the <code>brush</code> function which now takes a different form:</p>

<div class="example">


<pre><code>@import 'canvas';

html {
  background: canvas(320, 100,
    brush(
      0, 0,             // x1 and y1, the start point of the gradient
      0, 100,           // x2 and y2, the end point of the gradient
                        // x1 == x2 therefore this is a vertical gradient
      #f00, #0f0, #00f  // colour stops
    )
    paint
  );
}
</code></pre>

<p><img src="assets/images/example-12.png" alt="Example 12" /></p>

</div>




<div class="example">


<pre><code>@import 'canvas';

html {
  background: canvas(100, 100,
    brush(
      0, 0,             // x1 and y1, the start point of the gradient
      100, 100,         // x2 and y2, the end point of the gradient
                        // x1 &lt;&gt; x2, y1 &lt;&gt; y1 therefore this is a diagonal gradient
      #f00, #0f0, #00f  // colour stops
    )
    paint
  );
}
</code></pre>

<p><img src="assets/images/example-13.png" alt="Example 13" /></p>

</div>


<p>The colour stops are defined as a list of colours. The stops will be placed evenly throughout the axis of the gradient.
For example, a gradient with two colour stops will put these at (0%, 100%).
Three colour stops will be placed at (0%, 50%, 100%).
If you would like to adjust the offsets manually, add it next the colour:</p>

<div class="example">


<pre><code>@import 'canvas';

html {
  background: canvas(320, 100,
    brush(
      0, 0,                     // x1 and y1, the start point of the gradient
      320, 0,                   // x2 and y2, the end point of the gradient
                                // y1 == y2 therefore this is a horizontal gradient
      #f00 25%, #0f0, #00f 75%  // colour stops, note the additional offsets
    )
    paint
  );
}
</code></pre>

<p><img src="assets/images/example-14.png" alt="Example 14" /></p>

</div>


<h4>Radial Gradients</h4>

<p>Radial gradients are defined by two circles with <code>x</code>, <code>y</code> and <code>radius</code> properties:</p>

<div class="example">


<pre><code>@import 'canvas';

html {
  background: canvas(200, 200,
    brush(
      100, 100, 100,    // outer circle, take up the entire surface
      50,  50,  25,     // inner circle, smaller in the top-left corner
      #000, #ccc, #fff  // colour stops
    )
    paint
  );
}
</code></pre>

<p><img src="assets/images/example-15.png" alt="Example 15" /></p>

</div>


<h3>Drawing revised</h3>

<p>The default line width for a new canvas is 1. You can change it by using the <a href="#line-width"><code>line-width</code></a> function. The width will persist until you change it.</p>

<div class="example">


<pre><code>@import 'canvas';

html {
  background: canvas(320, 100,
    line-width(20)
    move-to(20, 20)
    line-to(200, 20)
    stroke
    reset
    move-to(20, 50)
    line-to(200, 50)
    stroke
    reset
    move-to(20, 80)
    line-to(200, 80)
    stroke
  );
}
</code></pre>

<p><img src="assets/images/example-16.png" alt="Example 16" /></p>

</div>


<p>When lines are drawn, different rules can be applied at their endpoints. In the example above, all lines use the default <a href="#line-cap-butt"><code>butt</code></a> style.
You can also choose between <a href="#line-cap-square"><code>square</code></a> and <a href="#line-cap-round"><code>round</code></a>:</p>

<div class="example">


<pre><code>@import 'canvas';

html {
  background: canvas(320, 100,
    line-width(20)
    move-to(20, 20)
    line-to(200, 20)
    line-cap(butt)   // default
    stroke
    reset
    move-to(20, 50)
    line-to(200, 50)
    line-cap(square)
    stroke
    stroke
    reset
    move-to(20, 80)
    line-to(200, 80)
    line-cap(round)
    stroke
  );
}
</code></pre>

<p><img src="assets/images/example-17.png" alt="Example 17" /></p>

</div>


<p>A line with <code>square</code> and <code>round</code> endpoint styles will have different length from a line with the default <code>butt</code> style.</p>

<h4>Dash patterns</h4>

<p>CSS has a very useful <code>border-style</code> property allowing you to control the appearance of a border, e.g., solid, dashed, dotted, etc.
Canvas lets you control the dash pattern so you can define any arbitrary outline style.</p>

<p>The relevant function is <a href="#dash-pattern"><code>dash-pattern</code></a>. When called with one argument, it resets the dash pattern and restores the original solid outline.</p>

<p>When called with two or more arguments, a new dash pattern is constructed and applied to all future <code>stroke</code> actions.
The arguments are the lengths of the alternating on/off segments:</p>

<div class="example">


<pre><code>@import 'canvas';

html {
  background: canvas(320, 50,
    move-to(10, 10)
    line-to(310, 10)
    dash-pattern(4, 2)        // 4px drawn, 2px transparent, repeat
    brush(red)
    stroke

    reset
    move-to(10, 20)
    line-to(310, 20)
    dash-pattern(2, 1, 1, 2)  // 2px drawn, 1px transparent, 1px drawn, 2px transparent, repeat
    brush(green)
    stroke

    reset
    move-to(10, 30)
    line-to(310, 30)
    dash-pattern(10, 10)      // 10px drawn, 10px transparent, repeat
    brush(blue)
    stroke

    reset
    move-to(10, 40)
    line-to(310, 40)
    dash-pattern(none)        // solid outline
    brush(#f0f)
    stroke
  );
}
</code></pre>

<p><img src="assets/images/example-18.png" alt="Example 18" /></p>

</div>


<h4>Fill Rules</h4>

<p>If your shape is complex and potentially self-intersecting, fill rules determine how those intersecting regions will be treated.
The default rule is <a href="#fill-rule-winding"><code>winding</code></a>:</p>

<div class="example">


<pre><code>@import 'canvas';

html {
  background: canvas(320, 100,
    triangle(160, 10, 10, 90, 310, 90)
    triangle(60, 50, 160, 90, 260, 50)
    fill
  );
}
</code></pre>

<p><img src="assets/images/example-19.png" alt="Example 19" /></p>

</div>


<p>The first triangle is draw in order top-centre, bottom-left, bottom-right.
The second triangle is draw in order top-left, bottom-centre, top-right.</p>

<p>If you change the order of the second triangle to bottom-centre, top-left, top-right you would get different results:</p>

<div class="example">


<pre><code>@import 'canvas';

html {
  background: canvas(320, 100,
    triangle(160, 10, 10, 90, 310, 90)
    triangle(160, 90, 60, 50, 260, 50)
    fill
  );
}
</code></pre>

<p><img src="assets/images/example-20.png" alt="Example 20" /></p>

</div>


<p>It is important to be very careful when intersecting paths. If you are unsure, split the path in individual shapes when possible.</p>

<p>The only other rule is <a href="#fill-rule-even-odd"><code>even-odd</code></a> and it can be set using the <a href="#fill-rule"><code>fill-rule</code></a> function.
It is easier to understand as it only counts the total number of intersections regardless of the order in which the operations were carried.
If the total number is odd, the point will be filled. If the total number if even, the point will be left untouched.</p>

<div class="example">


<pre><code>@import 'canvas';

html {
  background: canvas(320, 240,
    rectangle(10, 10, 310, 100)   // default rule is winding
    rectangle(20, 20, 300, 90)    // intersect with rectangle above
    brush(red)
    fill                          // entire region is filled since directions of the two rectangle match

    reset
    fill-rule(even-odd)           // change rule
    rectangle(10, 130, 310, 220)  // first rectangle, total = 1
    rectangle(20, 140, 300, 210)  // intersection with first rectangle, total = 2
    brush(blue)                   // only fills points with total = 1, i.e., excludes the second rectangle
    fill
  );
}
</code></pre>

<p><img src="assets/images/example-21.png" alt="Example 21" /></p>

</div>


<h3>Transforms</h3>

<p>Paths can be moved, scaled and rotated. When you begin a transformation, it will be applied to all future paths.
To avoid having transformations applied until the end of the canvas, use the <a href="#save"><code>save</code></a> and <a href="#restore"><code>restore</code></a> functions.
<code>save</code> creates a backup of the transformation matrix currently in use (for a new canvas this would be the identity matrix, i.e., no transformation).
<code>restore</code> returns the transformation matrix to the backed up copy.</p>

<p>The two functions can also be used to save/restore brushes, fill rules and other options.</p>

<p>Canvas already ships with functions for drawing arcs and circles, but with no support for drawing an ellipsis.
You can create one by applying transformations to a circle:</p>

<ul>
<li><a href="#rotate"><code>rotate</code></a> - rotates paths by angle</li>
<li><a href="#translate"><code>translate</code></a> - translates paths coordinates by (x, y)</li>
<li><a href="#scale"><code>scale</code></a> - scales paths by (width, height)</li>
</ul>


<div class="example">


<pre><code>@import 'canvas';

html {
  background: canvas(320, 200,
    brush(#ccc)
    paint
    save
      rotate(45)
      translate(20, -80)
      scale(1, 0.5)
      circle(160, 100, 100)
    restore
    brush(red)
    fill
    brush(black)
    stroke
  );
}
</code></pre>

<p><img src="assets/images/example-22.png" alt="Example 22" /></p>

</div>


<p>The order of transformations matters. In the example above, moving <code>translate</code> before <code>rotate</code> would yield different results.</p>

<p>Note the <code>fill</code> and <code>stroke</code> actions are placed after the <code>restore</code> action otherwise the line width for the <code>stroke</code> action will be scaled as well.</p>

<p><a name="arc-reverse"></a>
<a name="arc"></a>
<a name="brush"></a>
<a name="circle"></a>
<a name="curve-to"></a>
<a name="dash-pattern"></a>
<a name="fill-rule-even-odd"></a>
<a name="fill-rule-winding"></a>
<a name="fill-rule"></a>
<a name="fill"></a>
<a name="line-cap-butt"></a>
<a name="line-cap-round"></a>
<a name="line-cap-square"></a>
<a name="line-to"></a>
<a name="line-width"></a>
<a name="move-to"></a>
<a name="paint"></a>
<a name="rectangle"></a>
<a name="reset"></a>
<a name="restore"></a>
<a name="rotate"></a>
<a name="rounded-rectangle"></a>
<a name="save"></a>
<a name="scale"></a>
<a name="stroke"></a>
<a name="translate"></a>
<a name="triangle"></a></p>

<h2>Reference (missing)</h2>

<p><a href="http://rubydoc.info/gems/compass-canvas/frames">RDoc is available</a> for the entire project.</p>

<p>For more information on Cairo, visit <a href="http://zetcode.com/tutorials/cairographicstutorial/">The Cairo graphics tutorial</a>.</p>

<p>For a complete reference on Cairo methods, visit <a href="http://cairographics.org/documentation/pycairo/3/reference/context.html#class-context">Pycairo documentation</a>.</p>

</article>

</body>
</html>
